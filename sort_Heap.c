// Sort - Heap Sort
/*
adjust 함수는 마지막 부모노드에서부터 근노드까지 거슬러 올라가며 단계별로 최대힙구조로 만드는 알고리즘.
            자식노드 두개를 먼저 비교하고, 그중 큰 자식노드와 부모노드를 바꿈.
            자식노드로 내려온 부모노드는 그 아래 자식노드와 비교당함

heap_sort 함수는 1. 초기 최대힙구조로 만들기 수행
                 2. 최대힙구조에서 정렬 수행  
                    -> 근노드(최댓값)과 마지막노드(작은값.. a[cnt-1])을 swap하고 a[0]에서 a[cnt-2]까지 adjust하여 다시 최대힙구조로 만듦
                    -> 첫번째 최댓값은 a[cnt-1]에, 두번째 최댓값은 a[cnt-2]에...... 마지막 최솟값은 a[0]에 들어가며 오름차순 정렬 완성됨
*/



#include <stdio.h>

void adjust(int a[], int mid, int cnt){     // 최대힙구조 만드는 알고리즘.. mid에서 cnt값 까지를 최대힙구조로 만듦 -> a[mid-1:cnt-1]
    int j, k, done;
    done = 0;                           // 아래 while문 빠져나오기 위한  trigger -> 부모노드가 자식노드들보다 크면 트리거 작동
    k = a[mid-1];                       // k에는 부모노드의 data값이 담김
    j = 2*mid;                          // j에는 오른쪽 자식노드의 key(위치) 값  -> a[j-1]은 왼쪽자식, a[j]는 오른쪽자식

    while( (j<=cnt) && (!done) ){       // 자식노드가 배열 안에 있어야하고, 트리거가 작동되지 않은 상태
        if(j<cnt){                      // 1번 if. 오른쪽 자식이 배열크기-1보다 작을때 -> 완전끝이 아닐때
            if(a[j-1] < a[j])           //          오른쪽자식이 왼쪽자식보다 크면
                j++;                    //          j 위치를 ++시킴 (건너서 오른쪽으로 보내라..?)
        }
        
                        
        if(k>=a[j-1])   done=1;         // 2번 if.  k(부모노드값) >= 왼쪽자식값 이면 트리거 작동. 바로 빠져나옴 -> 바꿀 필요가 없음
                                        // 만약에 1번 if에서 왼쪽자식이 오른쪽자식보다 작았다면 이미 j++되었기때문에 
                                        // 부모(k)가 a[j-1] (앞에서 j++되었기때문에 얘가 오른쪽자식이 됨)보다 크다면 최대힙구조가 됨.
                                        // 만약에 1번 if에서 왼쪽자식이 오른쪽자식보다 컸다면... k가 왼쪽자식보다 크면 최대힙구조가 됨.
        else{                           // 부모가 자식보다 작아?
            a[j/2-1] = a[j-1];          // a[j/2-1] 은 부모(k)의 위치임. 부모값에 자식값을 넣고 (부모보다 큰 자식과 부모를 swap)
            j = 2*j;                    // j*=2를 통해 바뀐자리의 자식노드과 비교
        }
    }
    a[j/2-1] = k;                       // while 마지막에 j*=2로 보내놨기 때문에 while이 멈추면 다시 한칸 올려줘야함. 부모였던 노드의 값을 넣어줌 
                                        // while이 작동되지 않으면 a[mid-1]=a[mid-1] 그대로임. 
}

void heap_sort(int a[], int cnt){
    int i, tmp;
    for(i=cnt/2; i>0; i--)              // 1. 초기 최대힙구조 만들기 수행
        adjust(a, i, cnt);              // heap에서 cnt는 node 갯수이다. 힙에서 i(=node갯수/2)는 자식이 있는 마지막 부모위치
                                        // i에서부터 cnt(마지막)까지 adjust 수행  -> 자기 자식이 아닌애들은 안건드려짐
                                        // i를 한칸씩 앞당기며 모든 부모노드들 조정한다.
                                        
    for(i=cnt-1; i>0; i--){             // 2. 최대힙구조에서 정렬 수행    
        tmp = a[i];                     // 근노드(root node, 최댓값)와 마지막 노드(작은값)를 교환(swap)한 후 adjust 할겁니다.
        a[i] = a[0];                    // 
        a[0] = tmp;                     // 최대힙에서 근노드는 최댓값이었는데 마지막노드로가서 고정되고, 작은값들이 올라가서 adjust 수행됨

        adjust(a, 1, i);                // ----->>>> 1(근노드)에서부터 i(=cnt-1...마지막으로간 최댓값은 안건드리고 놔둠) 까지 adjust
        
    }                                   // 끝에서부터 최댓값들이 채워져 결과적으로는 최소힙구조가 됨. 근노드부터 하향식으로 레벨오더 운행하면 정렬된 결과 얻어짐
}                                       //   -> 배열대로 뽑으면 오름차순으로 나옴


int main()
{
    int a[] = {3, 10, 21, 7, 30, 60, 50, 40, 5, 31, 22, 19, 16,  2, 15, 9, 88, 47, 1, 16, 8};
    int i, cnt;                     // heap에서 cnt는 node 갯수이다.
    
    cnt = sizeof(a)/sizeof(int);
    heap_sort(a,cnt);
    
    printf("\n Result of Sort : ");
    for(i=0; i<cnt; i++)
        printf("%3d",a[i]);
        
    return 0;
}
